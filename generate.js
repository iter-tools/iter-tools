const fs = require('fs');
const path = require('path');
const recursive = require('recursive-readdir');
const babel = require('@babel/core');
const CLIEngine = require('eslint').CLIEngine;
const parseArgs = require('minimist');
const sane = require('sane');
const camelcase = require('camelcase');

const generatedFunctionFile = require('./templates/generated-function-file');
const generatedTestFile = require('./templates/generated-test-file');
const generationErrorFile = require('./templates/generation-error-file');
const gitattributesFile = require('./templates/gitattributes-file');
const test$File = require('./templates/test-$-file');

const argv = parseArgs(process.argv.slice(2), { alias: { w: 'watch' } });

const linter = new CLIEngine({ fix: true });

const { dirname, relative, join, resolve, basename } = path;

const srcDir = './src';
const templateRegex = /(.*)\.template\.js$/;
const ADD = 'ADD';
const REMOVE = 'REMOVE';

const publicTemplateRegex = /^src\/([^\/]*)\.template\.js$/

function handleError(e) {
  console.error(e);
  process.exit(1);
}

function processPath(templateFilename, operation, generatedPaths) {
  const dir = dirname(templateFilename);
  const base = basename(templateFilename, '.template.js');

  for (const ASYNC of [true, false]) {
    const isTest = templateFilename.includes('/__tests__/');
    const destExt = isTest ? 'js' : 'mjs';
    const destFilename = join(dir, ASYNC ? `async-${base}.${destExt}` : `${base}.${destExt}`);

    try {
      if (operation === REMOVE) {
        let generatedFromTag;

        try {
          const buf = Buffer.alloc(15);
          const fd = fs.openSync(destFilename);
          try {
            // TODO find some way to get the @generated-from tag length and offset dynamically
            fs.readSync(fd, buf, 0, 15, 7);
          } finally {
            fs.closeSync(fd);
          }
          generatedFromTag = buf.toString();
        } catch(e) { }

        if (generatedFromTag === "@generated-from") {
          fs.unlinkSync(destFilename);
          generatedPaths.delete(destFilename);
        }
      } else {
        let content
        let pathToTemplate = relative(dirname(destFilename), templateFilename)

        try {
          const impl = babel.transformFileSync(templateFilename, {
            babelrc: false,
            configFile: false,
            plugins: [
              ['./babel-plugin-resolve-$-import-paths', { ASYNC }],
              ['macros', { async: { ASYNC } }],
              // use dead code elimination to clean up if(false) {} and if(true) {}
              ['minify-dead-code-elimination', { keepFnName: true, keepFnArgs: true, keepClassName: true }],
            ],
          }).code;

          const template = isTest ? generatedTestFile : generatedFunctionFile;

          content = linter.executeOnText(
            template(pathToTemplate, impl)
          ).results[0].output;
        } catch(e) {
          content = generationErrorFile(pathToTemplate, e);
        }

        fs.writeFileSync(destFilename, content, 'utf8');
        if (operation === ADD) {
          generatedPaths.add(destFilename);
        }
      }
    } catch (e) {
      handleError(e)
    }
  }
}

function updateMonolithicFiles(paths, generatedPaths) {
  fs.writeFileSync('.gitattributes', gitattributesFile(generatedPaths));

  const fns = [...paths]
    .filter(path => publicTemplateRegex.test(path))
    .map(path => camelcase(publicTemplateRegex.exec(path)[1]));

  fs.writeFileSync('./src/__tests__/fns.js', test$File(fns, false));
  fs.writeFileSync('./src/__tests__/async-fns.js', test$File(fns, true));
}

recursive(resolve(__dirname, srcDir)).then(initialPaths => {
  const generatedPaths = new Set();
  const paths = new Set();

  const addPath = path => {
    processPath(path, ADD, generatedPaths);
    console.log(`Picked up new method template: ${path}`);
    updateMonolithicFiles(paths, generatedPaths);
  };
  const removePath = path => {
    processPath(path, REMOVE, generatedPaths);
    console.log(`Removed files generated by deleted template: ${path}`);
    updateMonolithicFiles(paths, generatedPaths);
  };

  for (const absPath of initialPaths) {
    const path = relative(__dirname, absPath)
    if (templateRegex.test(path)) paths.add(path);
  }

  for (const path of paths) {
    processPath(path, ADD, generatedPaths);
  }

  updateMonolithicFiles(paths, generatedPaths);

  if (argv.watch) {
    console.log('Initial generation completed; watching for changes...')
    const watcher = sane(srcDir, { glob: '**/*.template.js' });

    watcher.on('change', path => processPath(join(srcDir, path)));
    watcher.on('add', path => addPath(join(srcDir, path)));
    watcher.on('delete', path => removePath(join(srcDir, path)));
  }
}).catch(handleError);
