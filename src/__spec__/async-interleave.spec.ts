/**
 * @generated-from ./$interleave.spec.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import assert from 'static-type-assert';
import { AsyncGeneratorIterator, AsyncPromise } from '../internal/async-iterable';
import AsyncInterleaveBuffer from '../methods/$interleave/internal/async-buffer';
import { asyncInterleave } from '..'; // Without options
// ############

assert<AsyncGeneratorIterator<string | number>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }
  })(['foo'], [2]),
);
assert<AsyncGeneratorIterator<string | number | Function>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }

    assert<AsyncPromise<boolean>>(b3.canTake());
    assert<AsyncPromise<Function | undefined>>(b3.take());

    if (await b3.canTake()) {
      assert<AsyncPromise<Function>>(b3.take());
      yield await b3.take();
    }
  })(['foo'], [2], [(_: any) => _]),
);
assert<AsyncGeneratorIterator<string | number | Function | {}>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
    b4: AsyncInterleaveBuffer<{}>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }

    assert<AsyncPromise<boolean>>(b3.canTake());
    assert<AsyncPromise<Function | undefined>>(b3.take());

    if (await b3.canTake()) {
      assert<AsyncPromise<Function>>(b3.take());
      yield await b3.take();
    }

    assert<AsyncPromise<boolean>>(b4.canTake());
    assert<AsyncPromise<{} | undefined>>(b4.take());

    if (await b4.canTake()) {
      assert<AsyncPromise<{}>>(b4.take());
      yield await b4.take();
    }
  })(['foo'], [2], [(_: any) => _], [{}]),
); // With options
// ############

assert<AsyncGeneratorIterator<string | number>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }
  },
  {})(['foo'], [2]),
);
assert<AsyncGeneratorIterator<string | number | Function>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }

    assert<AsyncPromise<boolean>>(b3.canTake());
    assert<AsyncPromise<Function | undefined>>(b3.take());

    if (await b3.canTake()) {
      assert<AsyncPromise<Function>>(b3.take());
      yield await b3.take();
    }
  },
  {})(['foo'], [2], [(_: any) => _]),
);
assert<AsyncGeneratorIterator<string | number | Function | {}>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
    b4: AsyncInterleaveBuffer<{}>,
  ) {
    assert<AsyncPromise<boolean>>(b1.canTake());
    assert<AsyncPromise<string | undefined>>(b1.take());

    if (await b1.canTake()) {
      assert<AsyncPromise<string>>(b1.take());
      yield await b1.take();
    }

    assert<AsyncPromise<boolean>>(b2.canTake());
    assert<AsyncPromise<number | undefined>>(b2.take());

    if (await b2.canTake()) {
      assert<AsyncPromise<number>>(b2.take());
      yield await b2.take();
    }

    assert<AsyncPromise<boolean>>(b3.canTake());
    assert<AsyncPromise<Function | undefined>>(b3.take());

    if (await b3.canTake()) {
      assert<AsyncPromise<Function>>(b3.take());
      yield await b3.take();
    }

    assert<AsyncPromise<boolean>>(b4.canTake());
    assert<AsyncPromise<{} | undefined>>(b4.take());

    if (await b4.canTake()) {
      assert<AsyncPromise<{}>>(b4.take());
      yield await b4.take();
    }
  },
  {})(['foo'], [2], [(_: any) => _], [{}]),
);
