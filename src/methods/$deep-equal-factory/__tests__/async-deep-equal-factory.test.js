/**
 * @generated-from ./$deep-equal-factory.test.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

/* eslint-disable no-unused-vars,import/no-duplicates,no-constant-condition */

import { asyncDeepEqualFactory, asyncWrap } from '../../..';
import { wrap as syncWrap } from '../../..';
describe('asyncDeepEqualFactory', () => {
  describe('iterableNullish: false', () => {
    const asyncDeepEqual = asyncDeepEqualFactory({
      iterableNullish: false,
      compareEquality: (a, b) => a == b,
    });
    it('null and undefined are handled by compare', async () => {
      expect(await asyncDeepEqual(null, undefined)).toBe(true);
      expect(await asyncDeepEqual(null, undefined, asyncWrap([]))).toBe(false);
    });
  });
  describe('compareValues: false', () => {
    const asyncDeepEqual = asyncDeepEqualFactory({
      compareValues: false,
    });
    it('throws if values are not iterable', async () => {
      let error;

      try {
        await asyncDeepEqual(4, null);
      } catch (e) {
        error = e;
      }

      expect(error).toMatchSnapshot();
    });
    it('still compares values on recursion', async () => {
      expect(await asyncDeepEqual(asyncWrap([1]), asyncWrap([1]))).toBe(true);
    });
    it('can still compare strings', async () => {
      expect(await asyncDeepEqual('abc', 'abc')).toBe(true);
    });
  });
  it('can have a custom value comparator', async () => {
    const asyncDeepNotEqual = asyncDeepEqualFactory({
      compareEquality: () => false,
    });
    expect(await asyncDeepNotEqual(1, 1)).toBe(false);
    const asyncDeepDoubleEqual = asyncDeepEqualFactory({
      iterableNullish: false,
      compareEquality: (a, b) => a == b,
    });
    expect(
      await asyncDeepDoubleEqual(
        asyncWrap([null, asyncWrap([null]), asyncWrap([asyncWrap([null])])]),
        asyncWrap([undefined, asyncWrap([undefined]), asyncWrap([asyncWrap([undefined])])]),
      ),
    ).toBe(true);
  });
  it('cannot have both compare and compareFactory arguments', async () => {
    let error;

    try {
      asyncDeepEqualFactory({
        compareEquality: _ => _,
        compareEqualityFactory: _ => _,
      });
    } catch (e) {
      error = e;
    }

    expect(error).toMatchSnapshot();
  });
  describe('syncEqualsAsync: false', () => {
    const asyncDeepEqual = asyncDeepEqualFactory({
      syncEqualsAsync: false,
    });
    it('does not consider sync iterables to equal async iterables', async () => {
      expect(await asyncDeepEqual(asyncWrap([1]), syncWrap([1]))).toBe(false);
      expect(await asyncDeepEqual(syncWrap([1]), syncWrap([1]))).toBe(true);
      expect(await asyncDeepEqual(asyncWrap([]), null)).toBe(true);
    });
  });
});
