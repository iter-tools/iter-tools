/**
 * @generated-from ./$deep-equal-factory.test.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

/* eslint-disable no-unused-vars,import/no-duplicates,no-constant-condition */

import { deepEqualFactory, wrap } from '../../..';
import { wrap as syncWrap } from '../../..';
describe('deepEqualFactory', () => {
  describe('iterableNullish: false', () => {
    const deepEqual = deepEqualFactory({
      iterableNullish: false,
      compareEquality: (a, b) => a == b,
    });
    it('null and undefined are handled by compare', () => {
      expect(deepEqual(null, undefined)).toBe(true);
      expect(deepEqual(null, undefined, wrap([]))).toBe(false);
    });
  });
  describe('compareValues: false', () => {
    const deepEqual = deepEqualFactory({
      compareValues: false,
    });
    it('throws if values are not iterable', () => {
      let error;

      try {
        deepEqual(4, null);
      } catch (e) {
        error = e;
      }

      expect(error).toMatchSnapshot();
    });
    it('still compares values on recursion', () => {
      expect(deepEqual(wrap([1]), wrap([1]))).toBe(true);
    });
    it('can still compare strings', () => {
      expect(deepEqual('abc', 'abc')).toBe(true);
    });
  });
  it('can have a custom value comparator', () => {
    const deepNotEqual = deepEqualFactory({
      compareEquality: () => false,
    });
    expect(deepNotEqual(1, 1)).toBe(false);
    const deepDoubleEqual = deepEqualFactory({
      iterableNullish: false,
      compareEquality: (a, b) => a == b,
    });
    expect(
      deepDoubleEqual(
        wrap([null, wrap([null]), wrap([wrap([null])])]),
        wrap([undefined, wrap([undefined]), wrap([wrap([undefined])])]),
      ),
    ).toBe(true);
  });
  it('cannot have both compare and compareFactory arguments', () => {
    let error;

    try {
      deepEqualFactory({
        compareEquality: _ => _,
        compareEqualityFactory: _ => _,
      });
    } catch (e) {
      error = e;
    }

    expect(error).toMatchSnapshot();
  });
});
