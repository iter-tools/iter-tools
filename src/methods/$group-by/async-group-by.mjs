/**
 * @generated-from ./$group-by.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { asyncIterableCurry } from '../../internal/async-iterable';
import { AsyncPartsIterator, AsyncSpliterator, split } from '../../internal/async-spliterator';

let warnedNullGetKeyDeprecation = false;

const warnNullGetKeyDeprecation = () => {
  if (!warnedNullGetKeyDeprecation) {
    console.warn(
      `\`${'asyncGroupBy'}(null, iterable)\` is deprecated and will be removed in iter-tools@8. ` +
        `Instead use ${'asyncGroup'}(iterable)`,
    );
    warnedNullGetKeyDeprecation = true;
  }
};

class AsyncGroupingSpliterator extends AsyncSpliterator {
  constructor(sourceIterator, getKey) {
    super(sourceIterator);
    this.getKey = getKey;
    this.key = undefined;
    this.item = null;
    this.idx = 0;
  }

  static async nullOrInstance(sourceIterator, getKey) {
    const inst = new AsyncGroupingSpliterator(sourceIterator, getKey);
    return (await inst._isEmpty()) ? null : inst;
  }

  async _isEmpty() {
    await this.buffer();
    return this.item.done;
  }

  async buffer() {
    const { key } = this;
    if (this.item === null) {
      this.item = await super.next();
      const { done, value } = this.item;
      if (!done) {
        this.key = await this.getKey(value, this.idx++);
      }
    }
    return this.key !== key;
  }

  async next() {
    const newGroup = await this.buffer();

    if (this.item.done) {
      return { value: undefined, done: true };
    } else {
      const { value } = this.item;

      if (!newGroup) {
        this.item = null;
      }

      return { value: newGroup ? split : value, done: false };
    }
  }
}

class AsyncGroupPartsIterator extends AsyncPartsIterator {
  async next() {
    const item = await super.next();
    if (!item.done) {
      await this.spliterator.buffer();
      return { value: [this.spliterator.key, item.value], done: false };
    } else {
      return item;
    }
  }
}

export async function* asyncGroupBy(source, getKey) {
  if (getKey === null) {
    warnNullGetKeyDeprecation();
  }

  yield* new AsyncGroupPartsIterator(
    await AsyncGroupingSpliterator.nullOrInstance(
      source[Symbol.asyncIterator](),
      getKey === null ? _ => _ : getKey,
    ),
  );
}

export default asyncIterableCurry(asyncGroupBy);
