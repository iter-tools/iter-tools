/**
 * @generated-from ./$deep-equal.test.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

/* eslint-disable no-unused-vars,import/no-duplicates,no-constant-condition */

import { asyncDeepEqual, asyncWrap } from '../../..';
import { wrap as syncWrap } from '../../..';
describe('asyncDeepEqual', () => {
  describe('given no values', () => {
    it('throws', async () => {
      let error;

      try {
        await asyncDeepEqual();
      } catch (e) {
        error = e;
      }

      expect(error).toMatchSnapshot();
    });
  });
  describe('given primitives', () => {
    it('returns true if all values are equal by Object.is', async () => {
      expect(await asyncDeepEqual(1, 1)).toBe(true);
      expect(await asyncDeepEqual(NaN, NaN)).toBe(true);
      expect(await asyncDeepEqual('abc', 'abc')).toBe(true);
    });
    it('returns false if not all values are equal by Object.is', async () => {
      expect(await asyncDeepEqual(0, 0, -0)).toBe(false);
    });
  });
  describe('given iterables', () => {
    it('returns true if contents are equal', async () => {
      expect(await asyncDeepEqual(asyncWrap([1]), asyncWrap([1]))).toBe(true);
    });
  });
  describe('given null', () => {
    it('returns true if contents are equal', async () => {
      expect(await asyncDeepEqual(null, undefined, asyncWrap([]))).toBe(true);
      expect(
        await asyncDeepEqual(
          asyncWrap([null, asyncWrap([[]]), asyncWrap([asyncWrap([null])])]),
          asyncWrap([[], asyncWrap([undefined]), asyncWrap([asyncWrap([undefined])])]),
        ),
      ).toBe(true);
    });
  });
  describe('given objects', () => {
    it('returns true if entries are deep equal', async () => {
      expect(
        await asyncDeepEqual(
          {
            key: 'val',
          },
          {
            key: 'val',
          },
        ),
      ).toBe(true);
    });
  });
  describe('given nested iterables', () => {
    it('returns true if contents are deep equal', async () => {
      expect(
        await asyncDeepEqual(
          asyncWrap([
            asyncWrap([1]),
            asyncWrap([asyncWrap([asyncWrap([2])])]),
            asyncWrap([asyncWrap([3])]),
          ]),
          asyncWrap([
            asyncWrap([1]),
            asyncWrap([asyncWrap([asyncWrap([2])])]),
            asyncWrap([asyncWrap([3])]),
          ]),
        ),
      ).toBe(true);
    });
  });
  it('Deep compares inside objects by default', async () => {
    expect(
      await asyncDeepEqual(
        asyncWrap([
          {
            a: asyncWrap([1]),
          },
          {
            b: asyncWrap([
              {
                c: asyncWrap([3]),
              },
            ]),
          },
        ]),
        asyncWrap([
          {
            a: asyncWrap([1]),
          },
          {
            b: asyncWrap([
              {
                c: asyncWrap([3]),
              },
            ]),
          },
        ]),
      ),
    ).toBe(true);
  });
  it('returns false if the contents are not deep equal', async () => {
    expect(
      await asyncDeepEqual(
        asyncWrap([asyncWrap([1]), asyncWrap([2]), asyncWrap([3])]),
        asyncWrap([asyncWrap([1]), asyncWrap([2]), asyncWrap([3])]),
        asyncWrap([asyncWrap([1]), asyncWrap([2]), null]),
      ),
    ).toBe(false);
  });
  it('considers sync iterables to equal async iterables', async () => {
    expect(
      await asyncDeepEqual(
        asyncWrap([asyncWrap([1]), syncWrap([2]), syncWrap([3])]),
        asyncWrap([syncWrap([1]), asyncWrap([2]), syncWrap([3])]),
      ),
    ).toBe(true);
  });
});
