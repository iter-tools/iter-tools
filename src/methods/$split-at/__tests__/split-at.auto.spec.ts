/**
 * @generated-from ./split-at.test.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

/* eslint-disable no-unused-vars,import/no-duplicates,no-constant-condition */

import { splitAt } from '../../..';
import { wrap, unwrap, unwrapDeep } from '../../../test/helpers';

describe('splitAt', () => {
  describe('spread destructuring', () => {
    describe('with 0 index', () => {
      it('when all values are in second part', () => {
        const [[...first], [...second]] = splitAt(0, wrap([0, 1, 2, 3, 4, 5]));
        expect([first, second]).toEqual([[], [0, 1, 2, 3, 4, 5]]);
      });
    });

    describe('with positive index', () => {
      it('works when the halves are consumed in order', () => {
        const [[...first], [...second]] = splitAt(3, wrap([0, 1, 2, 3, 4, 5]));
        expect([first, second]).toEqual([[0, 1, 2], [3, 4, 5]]);
      });

      it('works when the source is exhuasted while the first half is being consumed', () => {
        const [[...first], [...second]] = splitAt(3, wrap([0, 1]));
        expect([first, second]).toEqual([[0, 1], []]);
      });

      it('works when the source is exhuasted while the second half is being consumed', () => {
        const [[...first], [...second]] = splitAt(3, wrap([0, 1, 2, 3]));
        expect([first, second]).toEqual([[0, 1, 2], [3]]);
      });
    });

    describe('with negative index', () => {
      it('works when the halves are consumed in order', () => {
        const [[...first], [...second]] = splitAt(-3, wrap([0, 1, 2, 3, 4, 5]));
        expect([first, second]).toEqual([[0, 1, 2], [3, 4, 5]]);
      });

      it('all values are in the first part when |index| is larger than source size', () => {
        const [[...first], [...second]] = splitAt(-3, wrap([0, 1]));
        expect([first, second]).toEqual([[0, 1], []]);
      });
    });
  });

  describe('with positive index', () => {
    it('works when the halves are consumed in order', () => {
      const [first, second] = splitAt(3, wrap([0, 1, 2, 3, 4, 5]));
      expect(unwrapDeep([first, second])).toEqual([[0, 1, 2], [3, 4, 5]]);
    });

    it('works when the source is exhuasted while the first half is being consumed', () => {
      const [first, second] = splitAt(3, wrap([0, 1]));
      expect(unwrapDeep([first, second])).toEqual([[0, 1], []]);
    });

    it('works when the source is exhuasted while the second half is being consumed', () => {
      const [first, second] = splitAt(3, wrap([0, 1, 2, 3]));
      expect(unwrapDeep([first, second])).toEqual([[0, 1, 2], [3]]);
    });
  });

  describe('with negative index', () => {
    it('works when the halves are consumed in order', () => {
      const [first, second] = splitAt(-3, wrap([0, 1, 2, 3, 4, 5]));
      expect(unwrapDeep([first, second])).toEqual([[0, 1, 2], [3, 4, 5]]);
    });

    it('all values are in the first part when |index| is larger than source size', () => {
      const [first, second] = splitAt(-3, wrap([0, 1]));
      expect(unwrapDeep([first, second])).toEqual([[0, 1], []]);
    });
  });

  it('allows the first half to be skipped', () => {
    const [, second] = splitAt(3, wrap([0, 1, 2, 3, 4, 5]));
    expect(unwrap(second)).toEqual([3, 4, 5]);
  });

  it('throws if only the first half is taken', () => {
    const splits = splitAt(3, wrap([0, 1, 2, 3, 4, 5]));
    splits.next();
    expect(() => splits.return()).toThrowErrorMatchingSnapshot();
  });

  it('throws when the second half is consumed before the first', () => {
    const [first, second] = splitAt(3, wrap([0, 1, 2, 3, 4, 5]));
    expect(unwrap(second)).toEqual([3, 4, 5]);

    expect(
      (() => {
        try {
          unwrap(first);
        } catch (e) {
          return e;
        }
      })(),
    ).toMatchSnapshot();
  });
});
