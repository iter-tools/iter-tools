/**
 * @generated-from ./$split-at.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { CircularBuffer } from '../../internal/circular-buffer';
import { asyncIterableCurry } from '../../internal/async-iterable';
import { AsyncBisector } from '../../internal/async-bisector';
import { wrap } from '../../internal/wrap';
import { asyncPeekerate } from '../$peekerate/async-peekerate';

export async function* asyncIndexSplitStrategy(split, { idx }, source) {
  const sourcePeekr = await asyncPeekerate(source);
  const fromEnd = idx < 0;
  const offset = Math.abs(idx);
  const buffer = fromEnd ? new CircularBuffer(offset) : null;
  let currentPos = 0;
  let yielded = 0;
  let sourceDone = false;

  try {
    let value;
    /* eslint-disable no-unmodified-loop-condition */
    while ((fromEnd || currentPos < idx) && !sourcePeekr.done) {
      /* eslint-enable no-unmodified-loop-condition */
      currentPos++;
      ({ value } = sourcePeekr);

      if (fromEnd) {
        value = buffer.push(value);
      }

      if (!fromEnd || currentPos > offset) {
        yield value;
        yielded++;
      }

      await sourcePeekr.advance();
    }

    if (fromEnd) {
      let i = yielded;
      while (buffer.size && i++ < offset) {
        yield buffer.shift();
      }
    }

    yield split;

    if (fromEnd) {
      yield* buffer;
    } else {
      while (!sourcePeekr.done) {
        yield sourcePeekr.value;
        await sourcePeekr.advance();
      }
    }
    sourceDone = true;
  } finally {
    if (!sourceDone) {
      sourcePeekr.return();
    }
  }
}

export function asyncSplitAt(source, idx) {
  return wrap(new AsyncBisector(source, asyncIndexSplitStrategy, { idx }));
}

export default asyncIterableCurry(asyncSplitAt, {
  forceSync: true,
});
