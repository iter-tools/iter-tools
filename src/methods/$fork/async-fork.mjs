/**
 * @generated-from ./$fork.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { asyncEnsureIterable, asyncIsIterable } from '../../internal/async-iterable';
import { Exchange } from '../../internal/queues';

function fetch(state) {
  const { exchange, iterator } = state;
  return new Promise((resolve, reject) => {
    iterator
      .next()
      .then(newItem => {
        if (newItem.done) {
          state.done = true;
          state.doneValue = newItem.value;
          return resolve();
        } else {
          exchange.push(newItem.value);
          return resolve();
        }
      })
      .catch(err => reject(err));
  });
}

async function returnIterator(state) {
  const { exchange, iterableCounter, iterator } = state;

  if (!exchange.hasRoot() && iterableCounter === 0) {
    if (typeof iterator.return === 'function') await iterator.return();
  }
}

async function* generateFork(state, consumer) {
  try {
    state.iterableCounter++;
    yield 'ensure finally';

    while (true) {
      if (!consumer.isEmpty()) {
        yield consumer.shift();
      } else if (state.done) {
        return state.doneValue;
      } else {
        await fetch(state);
      }
    }
  } finally {
    state.iterableCounter--;
    await returnIterator(state);
  }
}

function* generateForks(state, n) {
  const { exchange } = state;

  try {
    for (let counter = 0; counter < n; counter++) {
      const fork = generateFork(state, exchange.spawnConsumerAtRoot()); // this first call to "next" allows to initiate the function generator
      // this ensures that "iterableCounter" will be always increased and decreased
      //
      // the default behaviour of a generator is that finally clause is only called
      // if next was called at least once

      fork.next(); // ensure finally

      yield fork;
    }
  } finally {
    exchange.discardRoot();
    returnIterator(state);
  }
}

export function asyncFork(iterable, n = Infinity) {
  const state = {
    iterator: asyncEnsureIterable(iterable)[Symbol.asyncIterator](),
    iterableCounter: 0,
    exchange: new Exchange(),
    done: false,
    doneValue: undefined,
  };
  return generateForks(state, n);
}
export default function curriedFork(...args) {
  if (args.length >= 2) {
    const [n, iterable] = args;
    return asyncFork(iterable, n);
  }

  if (args.length === 0) {
    return asyncFork;
  }

  if (asyncIsIterable(args[0])) {
    return asyncFork(args[0], undefined);
  } else {
    return iterable => asyncFork(iterable, args[0]);
  }
}
