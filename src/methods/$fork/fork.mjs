/**
 * @generated-from ./$fork.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { ensureIterable, isIterable } from '../../internal/iterable';
import { Exchange } from '../../internal/queues';

function fetch(state) {
  const { exchange, iterator } = state;
  {
    const newItem = iterator.next();

    if (newItem.done) {
      state.done = true;
      state.doneValue = newItem.value;
    } else {
      exchange.push(newItem.value);
    }
  }
}

function returnIterator(state) {
  const { exchange, iterableCounter, iterator } = state;

  if (!exchange.hasRoot() && iterableCounter === 0) {
    if (typeof iterator.return === 'function') iterator.return();
  }
}

function* generateFork(state, consumer) {
  try {
    state.iterableCounter++;
    yield 'ensure finally';

    while (true) {
      if (!consumer.isEmpty()) {
        yield consumer.shift();
      } else if (state.done) {
        return state.doneValue;
      } else {
        fetch(state);
      }
    }
  } finally {
    state.iterableCounter--;
    returnIterator(state);
  }
}

function* generateForks(state, n) {
  const { exchange } = state;

  try {
    for (let counter = 0; counter < n; counter++) {
      const fork = generateFork(state, exchange.spawnConsumerAtRoot()); // this first call to "next" allows to initiate the function generator
      // this ensures that "iterableCounter" will be always increased and decreased
      //
      // the default behaviour of a generator is that finally clause is only called
      // if next was called at least once

      fork.next(); // ensure finally

      yield fork;
    }
  } finally {
    exchange.discardRoot();
    returnIterator(state);
  }
}

export function fork(iterable, n = Infinity) {
  const state = {
    iterator: ensureIterable(iterable)[Symbol.iterator](),
    iterableCounter: 0,
    exchange: new Exchange(),
    done: false,
    doneValue: undefined,
  };
  return generateForks(state, n);
}
export default function curriedFork(...args) {
  if (args.length >= 2) {
    const [n, iterable] = args;
    return fork(iterable, n);
  }

  if (args.length === 0) {
    return fork;
  }

  if (isIterable(args[0])) {
    return fork(args[0], undefined);
  } else {
    return iterable => fork(iterable, args[0]);
  }
}
