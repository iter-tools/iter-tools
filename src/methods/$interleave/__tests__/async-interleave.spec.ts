/**
 * @generated-from ./$interleave.spec.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import assert from 'static-type-assert';
import { AsyncResultIterable } from '../../../types/async-iterable';
import AsyncInterleaveBuffer from '../internal/async-buffer';
import { asyncInterleave } from '../../..';

// Without options
// ############

assert<AsyncResultIterable<string | number>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
  })(['foo'], [2]),
);

assert<AsyncResultIterable<string | number | Function>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
    assert<Promise<boolean>>(b3.canTake());
    assert<Promise<Function | undefined>>(b3.take());
    if (await b3.canTake()) {
      assert<Promise<Function>>(b3.take());
      yield await b3.take();
    }
  })(['foo'], [2], [(_: any): any => _]),
);

assert<AsyncResultIterable<string | number | Function | {}>>(
  asyncInterleave(async function*(
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
    b4: AsyncInterleaveBuffer<{}>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
    assert<Promise<boolean>>(b3.canTake());
    assert<Promise<Function | undefined>>(b3.take());
    if (await b3.canTake()) {
      assert<Promise<Function>>(b3.take());
      yield await b3.take();
    }
    assert<Promise<boolean>>(b4.canTake());
    assert<Promise<{} | undefined>>(b4.take());
    if (await b4.canTake()) {
      assert<Promise<{}>>(b4.take());
      yield await b4.take();
    }
  })(['foo'], [2], [(_: any): any => _], [{}]),
);

// With options
// ############

assert<AsyncResultIterable<string | number>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
  },
  {})(['foo'], [2]),
);

assert<AsyncResultIterable<string | number | Function>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
    assert<Promise<boolean>>(b3.canTake());
    assert<Promise<Function | undefined>>(b3.take());
    if (await b3.canTake()) {
      assert<Promise<Function>>(b3.take());
      yield await b3.take();
    }
  },
  {})(['foo'], [2], [(_: any): any => _]),
);

assert<AsyncResultIterable<string | number | Function | {}>>(
  asyncInterleave(async function*(
    options: {},
    canTakeAny: Function,
    b1: AsyncInterleaveBuffer<string>,
    b2: AsyncInterleaveBuffer<number>,
    b3: AsyncInterleaveBuffer<Function>,
    b4: AsyncInterleaveBuffer<{}>,
  ) {
    assert<Promise<boolean>>(b1.canTake());
    assert<Promise<string | undefined>>(b1.take());
    if (await b1.canTake()) {
      assert<Promise<string>>(b1.take());
      yield await b1.take();
    }
    assert<Promise<boolean>>(b2.canTake());
    assert<Promise<number | undefined>>(b2.take());
    if (await b2.canTake()) {
      assert<Promise<number>>(b2.take());
      yield await b2.take();
    }
    assert<Promise<boolean>>(b3.canTake());
    assert<Promise<Function | undefined>>(b3.take());
    if (await b3.canTake()) {
      assert<Promise<Function>>(b3.take());
      yield await b3.take();
    }
    assert<Promise<boolean>>(b4.canTake());
    assert<Promise<{} | undefined>>(b4.take());
    if (await b4.canTake()) {
      assert<Promise<{}>>(b4.take());
      yield await b4.take();
    }
  },
  {})(['foo'], [2], [(_: any): any => _], [{}]),
);
