/* @macrome
 * @generated-from ./$interleave.test.js
 * @generated-by generate/generators/$tests/index.js
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { Iterable } from '../../../types/iterable';
import { interleave, InterleaveBuffer, toArray } from '../../..';

describe('interleave', () => {
  const a = [1, 2, 3];
  const b = [4, 5, 6];
  const c = [7, 8, 9];

  it('can be used to implement a round robin interleave', () => {
    const roundRobin = interleave(function*(
      canTakeAny: () => InterleaveBuffer<number> | null,
      a: InterleaveBuffer<number>,
      b: InterleaveBuffer<number>,
      c: InterleaveBuffer<number>,
    ) {
      while (canTakeAny()) {
        if (a.canTake()) yield a.take();
        if (b.canTake()) yield b.take();
        if (c.canTake()) yield c.take();
      }
    });

    expect(toArray(roundRobin(a, b, c))).toEqual([1, 4, 7, 2, 5, 8, 3, 6, 9]);
  });

  it('can be passed options for the generator', () => {
    const options = {};

    expect.assertions(1);
    toArray(
      interleave(
        // eslint-disable-next-line require-yield
        function*(o: {}): Iterable<any> {
          expect(o).toBe(options);
        },
        options,
        null,
      ),
    );
  });

  describe('the return value of canTakeAny', () => {
    it('can be used to do concatenation', () => {
      const concatenate = interleave(function*(
        canTakeAny: () => InterleaveBuffer<number> | null,
        _a: InterleaveBuffer<number>,
        _b: InterleaveBuffer<number>,
        _c: InterleaveBuffer<number>,
      ) {
        let buffer = canTakeAny();

        while (buffer) {
          yield buffer.take();
          buffer = canTakeAny();
        }
      });

      expect(Array.from(concatenate(a, b, c))).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    });
  });
});
