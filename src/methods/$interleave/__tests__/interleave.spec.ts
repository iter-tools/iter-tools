/**
 * @generated-from ./$interleave.spec.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import assert from 'static-type-assert';
import { ResultIterable } from '../../../types/iterable';
import InterleaveBuffer from '../internal/buffer';
import { interleave } from '../../..';

// Without options
// ############

assert<ResultIterable<string | number>>(
  interleave(function*(
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
  })(['foo'], [2]),
);

assert<ResultIterable<string | number | Function>>(
  interleave(function*(
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
    b3: InterleaveBuffer<Function>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
    assert<boolean>(b3.canTake());
    assert<Function | undefined>(b3.take());
    if (b3.canTake()) {
      assert<Function>(b3.take());
      yield b3.take();
    }
  })(['foo'], [2], [(_: any): any => _]),
);

assert<ResultIterable<string | number | Function | {}>>(
  interleave(function*(
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
    b3: InterleaveBuffer<Function>,
    b4: InterleaveBuffer<{}>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
    assert<boolean>(b3.canTake());
    assert<Function | undefined>(b3.take());
    if (b3.canTake()) {
      assert<Function>(b3.take());
      yield b3.take();
    }
    assert<boolean>(b4.canTake());
    assert<{} | undefined>(b4.take());
    if (b4.canTake()) {
      assert<{}>(b4.take());
      yield b4.take();
    }
  })(['foo'], [2], [(_: any): any => _], [{}]),
);

// With options
// ############

assert<ResultIterable<string | number>>(
  interleave(function*(
    options: {},
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
  },
  {})(['foo'], [2]),
);

assert<ResultIterable<string | number | Function>>(
  interleave(function*(
    options: {},
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
    b3: InterleaveBuffer<Function>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
    assert<boolean>(b3.canTake());
    assert<Function | undefined>(b3.take());
    if (b3.canTake()) {
      assert<Function>(b3.take());
      yield b3.take();
    }
  },
  {})(['foo'], [2], [(_: any): any => _]),
);

assert<ResultIterable<string | number | Function | {}>>(
  interleave(function*(
    options: {},
    canTakeAny: Function,
    b1: InterleaveBuffer<string>,
    b2: InterleaveBuffer<number>,
    b3: InterleaveBuffer<Function>,
    b4: InterleaveBuffer<{}>,
  ) {
    assert<boolean>(b1.canTake());
    assert<string | undefined>(b1.take());
    if (b1.canTake()) {
      assert<string>(b1.take());
      yield b1.take();
    }
    assert<boolean>(b2.canTake());
    assert<number | undefined>(b2.take());
    if (b2.canTake()) {
      assert<number>(b2.take());
      yield b2.take();
    }
    assert<boolean>(b3.canTake());
    assert<Function | undefined>(b3.take());
    if (b3.canTake()) {
      assert<Function>(b3.take());
      yield b3.take();
    }
    assert<boolean>(b4.canTake());
    assert<{} | undefined>(b4.take());
    if (b4.canTake()) {
      assert<{}>(b4.take());
      yield b4.take();
    }
  },
  {})(['foo'], [2], [(_: any): any => _], [{}]),
);
