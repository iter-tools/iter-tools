/**
 * @generated-from ./$split-on-any-subseq.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { iterableCurry } from '../../internal/iterable';
import { PartsIterator, Spliterator, split } from '../../internal/spliterator';
import { CircularBuffer } from '../../internal/circular-buffer';
import { startsWithAnySubseq } from '../$starts-with-any-subseq/starts-with-any-subseq';
import map from '../$map/map';
import toArray from '../$to-array/to-array';

class AnySubseqSpliterator extends Spliterator {
  constructor(sourceIterator, separatorSubseqs, equals) {
    super(sourceIterator);
    this.separatorSubseqs = separatorSubseqs;
    this.equals = equals;
    const maxMatchLength = separatorSubseqs.reduce((max, { length }) => Math.max(max, length), 1);
    this.buffer = new CircularBuffer(maxMatchLength);
  }

  static nullOrInstance(sourceIterator, separatorSubseqs, equals) {
    const inst = new AnySubseqSpliterator(sourceIterator, separatorSubseqs, equals);
    return inst._isEmpty() ? null : inst;
  }

  _isEmpty() {
    let item;

    if (!(item = super.next()).done) {
      this.buffer.push(item.value);
    }

    return item.done;
  }

  getMatchingLength() {
    for (const subsequence of this.separatorSubseqs) {
      if (startsWithAnySubseq(this.buffer, [subsequence], this.equals)) {
        return subsequence.length;
      }
    }

    return 0;
  }

  next() {
    let item;

    while (!(this.buffer.isFull() || (item = super.next()).done)) {
      this.buffer.push(item.value);
    }

    if (!this.buffer.size) {
      return {
        value: undefined,
        done: true,
      };
    } else {
      const matchingLength = this.getMatchingLength(this.buffer, this.separatorSubseqs);

      if (matchingLength) {
        for (let i = 0; i < matchingLength; i++) {
          this.buffer.shift();
        }
      }

      return {
        value: matchingLength ? split : this.buffer.shift(),
        done: false,
      };
    }
  }
}

export function* splitOnAnySubseq(source, separatorSubseqs, equals) {
  const _separatorSubseqs = toArray(map(toArray, separatorSubseqs))
    .filter(subseq => subseq.length)
    .sort((a, b) => b.length - a.length);

  yield* new PartsIterator(
    AnySubseqSpliterator.nullOrInstance(source[Symbol.iterator](), _separatorSubseqs, equals),
  );
}
export default iterableCurry(splitOnAnySubseq, {
  maxArgs: 2,
  optionalArgsAtEnd: true,
});
