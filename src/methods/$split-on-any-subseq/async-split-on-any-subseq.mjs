/**
 * @generated-from ./$split-on-any-subseq.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { asyncIterableCurry } from '../../internal/async-iterable';
import { asyncSubseqsToArray } from '../../internal/async-any-subseq';
import { startsWithSubseq } from '../$starts-with-subseq/starts-with-subseq';
import { asyncLeadingWindow } from '../$leading-window/async-leading-window';
import { asyncSpliterate } from '../$spliterate/async-spliterate';

function getMatchingLength(buffer, separatorSubseqs) {
  for (const subsequence of separatorSubseqs) {
    if (startsWithSubseq(buffer, subsequence)) {
      return subsequence.length;
    }
  }

  return 0;
}

async function* asyncAnySubseqSpliterator(split, { separatorSubseqs }, source) {
  const maxMatchLength = separatorSubseqs.reduce((max, { length }) => Math.max(max, length), 1);

  let skip = 0;

  for await (const buffer of asyncLeadingWindow(source, maxMatchLength, { useFiller: false })) {
    if (skip > 0) {
      skip--;
      continue;
    }
    const matchingLength = getMatchingLength(buffer, separatorSubseqs);

    if (matchingLength > 0) {
      yield split;
      skip = matchingLength - 1;
    } else {
      yield buffer.get(0);
    }
  }
}

export async function* asyncSplitOnAnySubseq(source, separatorSubseqs) {
  const separatorSubseqsArr = (await asyncSubseqsToArray(separatorSubseqs)).filter(
    s => s.length > 0,
  );

  yield* asyncSpliterate(source, asyncAnySubseqSpliterator, {
    separatorSubseqs: separatorSubseqsArr.sort((a, b) => b.length - a.length),
  });
}

export default asyncIterableCurry(asyncSplitOnAnySubseq);
