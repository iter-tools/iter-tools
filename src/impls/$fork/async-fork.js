/**
 * @generated-from ./$fork.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { asyncIterableCurry, asyncCallReturn } from '../../internal/async-iterable.js';
import { Exchange } from './internal/exchange.js';

function fetch(state) {
  const { exchange, iterator } = state;

  return new Promise((resolve, reject) => {
    iterator
      .next()
      .then((newItem) => {
        if (newItem.done) {
          state.done = true;
          state.doneValue = newItem.value;
          return resolve();
        } else {
          exchange.push(newItem.value);
          return resolve();
        }
      })
      .catch((err) => reject(err));
  });
}

async function returnIterator(state) {
  const { exchange, iterableCounter, iterator } = state;

  if (!exchange.hasRoot() && iterableCounter === 0) {
    await asyncCallReturn(iterator);
  }
}

async function* generateFork(state, consumer) {
  try {
    state.iterableCounter++;
    yield 'ensure finally';
    while (true) {
      if (!consumer.isEmpty()) {
        yield consumer.shift();
      } else if (state.done) {
        return state.doneValue;
      } else {
        await fetch(state);
      }
    }
  } finally {
    state.iterableCounter--;
    await returnIterator(state);
  }
}

function* generateForks(source, state) {
  const { exchange } = state;

  state.iterator = source[Symbol.asyncIterator]();

  try {
    while (true) {
      const fork = generateFork(state, exchange.spawnConsumerAtRoot());
      // this first call to "next" allows to initiate the function generator
      // this ensures that "iterableCounter" will be always increased and decreased
      //
      // the default behaviour of a generator is that finally clause is only called
      // if next was called at least once
      fork.next(); // ensure finally
      yield fork;
    }
  } finally {
    exchange.discardRoot();
    returnIterator(state);
  }
}

export function asyncFork(source) {
  const state = {
    iterator: null,
    iterableCounter: 0,
    exchange: new Exchange(),
    done: false,
    doneValue: undefined,
  };

  return generateForks(source, state);
}

export default asyncIterableCurry(asyncFork, {
  forceSync: true,
});
