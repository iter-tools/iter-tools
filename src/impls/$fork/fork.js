/**
 * @generated-from ./$fork.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { iterableCurry, callReturn } from '../../internal/iterable.js';
import { Exchange } from './internal/exchange.js';

function fetch(state) {
  const { exchange, iterator } = state;

  {
    const newItem = iterator.next();
    if (newItem.done) {
      state.done = true;
      state.doneValue = newItem.value;
    } else {
      exchange.push(newItem.value);
    }
  }
}

function returnIterator(state) {
  const { exchange, iterableCounter, iterator } = state;

  if (!exchange.hasRoot() && iterableCounter === 0) {
    callReturn(iterator);
  }
}

function* generateFork(state, consumer) {
  try {
    state.iterableCounter++;
    yield 'ensure finally';
    while (true) {
      if (!consumer.isEmpty()) {
        yield consumer.shift();
      } else if (state.done) {
        return state.doneValue;
      } else {
        fetch(state);
      }
    }
  } finally {
    state.iterableCounter--;
    returnIterator(state);
  }
}

function* generateForks(source, state) {
  const { exchange } = state;

  state.iterator = source[Symbol.iterator]();

  try {
    while (true) {
      const fork = generateFork(state, exchange.spawnConsumerAtRoot());
      // this first call to "next" allows to initiate the function generator
      // this ensures that "iterableCounter" will be always increased and decreased
      //
      // the default behaviour of a generator is that finally clause is only called
      // if next was called at least once
      fork.next(); // ensure finally
      yield fork;
    }
  } finally {
    exchange.discardRoot();
    returnIterator(state);
  }
}

export function fork(source) {
  const state = {
    iterator: null,
    iterableCounter: 0,
    exchange: new Exchange(),
    done: false,
    doneValue: undefined,
  };

  return generateForks(source, state);
}

export default iterableCurry(fork, {
  forceSync: true,
});
