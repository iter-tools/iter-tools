/**
 * @generated-from ./$forkerate.test.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { forkerate, startsWithSeq, str } from 'iter-tools-es';
import { wrap, unwrap } from '../../../test/helpers.js';

describe('forkerate', () => {
  describe('forkerator', () => {
    it('yields values from source', () => {
      expect(unwrap(forkerate(wrap([1, 2, 3])).asIterator())).toEqual([1, 2, 3]);
    });
  });

  describe('fork', () => {
    it('yields values including and after forkr.current', () => {
      const forkr = forkerate(wrap([1, 2, 3]));

      expect(unwrap(forkr.fork())).toEqual([1, 2, 3]);
      expect(unwrap(forkr)).toEqual([1, 2, 3]);

      forkr.advance();

      expect(unwrap(forkr.fork())).toEqual([2, 3]);
      expect(unwrap(forkr)).toEqual([2, 3]);

      forkr.advance();

      expect(unwrap(forkr.fork())).toEqual([3]);
      expect(unwrap(forkr)).toEqual([3]);

      forkr.advance();

      expect(unwrap(forkr.fork())).toEqual([]);
      expect(unwrap(forkr)).toEqual([]);

      expect(forkr.fork().next()).toEqual({ value: undefined, done: true });
    });
  });

  it('can be used to strip comments', () => {
    expect(
      str(
        (function* stripComments(source) {
          let forkr = forkerate(source);

          while (true) {
            const isComment = startsWithSeq('//', forkr.fork());

            while (!forkr.done && forkr.value !== '\n') {
              if (!isComment) yield forkr.value;
              forkr = forkr.advance();
            }

            if (forkr.done) break;

            if (!isComment) yield '\n';
            forkr = forkr.advance();
          }
        })('// comment\ncode'),
      ),
    ).toBe('code');
  });
});
