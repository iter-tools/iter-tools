/**
 * @generated-from ./$peekerate.test.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { peekerate, str, interposeSeq } from 'iter-tools-es';
import { wrap } from '../../../test/helpers.js';
import { Iterable } from '../../../types/iterable.js';

describe('peekerate', () => {
  it('decorates iterator with the current value in the iterable', () => {
    const peekerator = peekerate(wrap([1, 2, 3]));
    const observed = [];

    while (!peekerator.done) {
      const { value, done, current } = peekerator;
      observed.push({ value, done, current });
      peekerator.advance();
    }

    expect(observed).toEqual([
      {
        value: 1,
        done: false,
        current: {
          value: 1,
          done: false,
        },
      },
      {
        value: 2,
        done: false,
        current: {
          value: 2,
          done: false,
        },
      },
      {
        value: 3,
        done: false,
        current: {
          value: 3,
          done: false,
        },
      },
    ]);
  });

  describe('asIterator', () => {
    // eslint-disable-next-line jest/expect-expect
    it('cleans up source iterable', () => {
      peekerate(wrap([1, 2, 3]))
        .asIterator()
        .return();
    });
  });

  describe('documentation examples', () => {
    it('README example works', () => {
      const printValues = (values: Iterable<number>) => {
        const peekr = peekerate(values);

        return peekr.done ? 'none' : str(interposeSeq(', ', peekr.asIterator()));
      };

      expect(printValues(wrap([]))).toBe('none');
      expect(printValues(wrap([1, 2, 3]))).toBe('1, 2, 3');
    });

    it('cookbook example works', () => {
      const printListEN = (values: Iterable<number>, oxfordComma = true) => {
        let peekr = peekerate(values);
        let result = '';
        let last = peekr.current;

        if (peekr.done) return 'none';

        while (!peekr.done) {
          last = peekr.current;
          peekr = peekr.advance();
          if (!peekr.done) {
            if (peekr.index > 1) result += ', ';
            result += last.value.toString();
          }
        }

        if (peekr.index > 2) {
          if (oxfordComma) {
            result += ', ';
          }
          result += 'and ';
        } else if (peekr.index > 1) {
          result += ' and ';
        }

        result += last.value!.toString();
        return result;
      };

      expect(printListEN(wrap([]))).toBe('none');
      expect(printListEN(wrap([1]))).toBe('1');
      expect(printListEN(wrap([1, 2]))).toBe('1 and 2');
      expect(printListEN(wrap([1, 2, 3]))).toBe('1, 2, and 3');
    });
  });
});
