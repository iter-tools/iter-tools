/**
 * @generated-from ./$slice.js
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { CircularBuffer } from '../../internal/circular-buffer.js';
import { asyncIterableCurry } from '../../internal/async-iterable.js';
import { makeValidateArgs } from './internal/validate-args.js';

export async function* __asyncSliceFromStart(source, start = 0, end = Infinity, step = 1) {
  let currentPos = 0;
  let nextValidPos = start;
  const bufferSize = Math.abs(end);
  let buffer;
  let counter = 0;

  if (end < 0) {
    buffer = new CircularBuffer(bufferSize);
  }

  for await (let value of source) {
    if (buffer) {
      value = buffer.push(value);
      counter++;
      if (counter <= bufferSize) {
        continue;
      }
    }

    if (currentPos >= end && end >= 0) {
      break;
    }

    if (nextValidPos === currentPos) {
      yield value;
      nextValidPos += step;
    }
    currentPos++;
  }
}

async function asyncBufferedSlice(source, start, end, step) {
  const bufferSize = Math.abs(start);
  const buffer = new CircularBuffer(bufferSize);
  let counter = 0;

  for await (const value of source) {
    buffer.push(value);
    counter++;
  }

  let newEnd;
  if (isFinite(end) && end > 0) {
    newEnd = end - (counter - buffer.size);
    if (newEnd < 0) return [];
  } else {
    newEnd = end;
  }
  return __asyncSliceFromStart(buffer, 0, newEnd, step);
}

export async function* __asyncSlice(source, start = 0, end = Infinity, step = 1) {
  if (start >= 0) {
    yield* __asyncSliceFromStart(source, start, end, step);
  } else {
    yield* await asyncBufferedSlice(source, start, end, step);
  }
}

export const asyncSlice = /*#__PURE__*/ asyncIterableCurry(__asyncSlice, {
  validateArgs: /*#__PURE__*/ makeValidateArgs('asyncSlice'),
  growRight: true,
  minArgs: 0,
  maxArgs: 3,
});
