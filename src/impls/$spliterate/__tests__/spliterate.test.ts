/**
 * @generated-from ./$spliterate.test.ts
 * This file is autogenerated from a template. Please do not edit it directly.
 * To rebuild it from its template use the command
 * > npm run generate
 * More information can be found in CONTRIBUTING.md
 */

import { spliterate } from 'iter-tools-es';
import { wrap, unwrapDeep } from '../../../test/helpers.js';

function* identityStrategy(_split: any, _options: any, source: any) {
  yield* source;
}

describe('spliterate', () => {
  let split: symbol;
  const testSpliterator = spliterate(function* (split_: any, options: any, source: any) {
    split = split_;
    yield* identityStrategy(split_, options, source);
  }, {});

  describe('when spliterator is empty', () => {
    it('yields no groups', () => {
      expect(unwrapDeep(testSpliterator(wrap([])))).toEqual([]);
    });
  });

  describe('when spliterator contains only a split', () => {
    it('yields two empty groups', () => {
      expect(unwrapDeep(testSpliterator(wrap([split])))).toEqual([[], []]);
    });
  });

  describe('when spliterator contains two splits', () => {
    it('yields three empty groups', () => {
      expect(unwrapDeep(testSpliterator(wrap([split, split])))).toEqual([[], [], []]);
    });
  });

  describe('when spliterator contains a trailing split', () => {
    it('yields three empty groups', () => {
      expect(unwrapDeep(testSpliterator(wrap([null, split])))).toEqual([[null], []]);
    });
  });

  describe('when spliterator contains a leading split', () => {
    it('yields three empty groups', () => {
      expect(unwrapDeep(testSpliterator(wrap([split, null])))).toEqual([[], [null]]);
    });
  });

  describe('abrupt termination', () => {
    // The assertions in these tests are part of the cleanup defined by $wrap
    /* eslint-disable jest/expect-expect */

    it("source is cleaned up if we're done before we started", () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      parts.return();
    });

    it('source is cleaned up if part manager is closed then active part', () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      const part = parts.next().value;
      part.next();
      parts.return();
      part.return();
    });

    it('source is cleaned up if active part is closed then part manager', () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      const part = parts.next().value;
      part.next();
      part.return();
      parts.return();
    });

    it('source is cleaned up if active part is done then part manager is closed', () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      const part = parts.next().value;
      part.next();
      part.next();
      parts.return();
    });

    it('source is cleaned up if part manager is closed then active part is done', () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      const part = parts.next().value;
      parts.return();
      part.next();
      part.next();
    });

    it('source is cleaned up if only parts are consumed', () => {
      const parts = testSpliterator(wrap(['first', split, 'second']));
      parts.next();
      parts.next();
      parts.next();
    });

    /* eslint-enable jest/expect-expect */
  });

  it('options may be omitted', () => {
    const testSpliterator = spliterate(identityStrategy);
    expect(unwrapDeep(testSpliterator([]))).toEqual([]);
  });
});
