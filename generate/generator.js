const fs = require('fs');
const { dirname, relative, join, resolve, basename } = require('path');
const recursive = require('recursive-readdir');
const babel = require('@babel/core');
const Linter = require('eslint').CLIEngine;
const parseArgs = require('minimist');
const sane = require('sane');
const { matcher } = require('micromatch');
const log = require('loglevel');

const generatedFunctionFile = require('../templates/generated-function-file');
const generatedTestFile = require('../templates/generated-test-file');
const generationErrorFile = require('../templates/generation-error-file');
const gitattributesFile = require('../templates/gitattributes-file');
const test$File = require('../templates/test-$-file');

const { argv } = require('./argv');

const { debounce } = require('./utils');
const { isGeneratedFromTemplate } = require('./comments');
const FileCache = require('./file-cache');
const traverse = require('./traverse');

const rootDir = resolve(__dirname, '..');
const srcDir = resolve(rootDir, 'src');
const ADD = 'ADD';
const REMOVE = 'REMOVE';
const isTemplate = matcher("src/**/*.template.js");

log.setLevel(argv.quiet ? 'error': 'info');

function handleError(e) {
  console.error(e);
  process.exit(1);
}

const ignored = ['.git', 'node_modules', 'es5', 'es2015', 'es2018', 'coverage'];

class Generator {
  constructor() {
    this.generatedPaths = new FileCache(rootDir);
    this.paths = new Set();
    this.updateMonolithicFiles = debounce(this.updateMonolithicFiles.bind(this), 50);
    this.linter = new Linter({ fix: true });
  }

  processPath(templateFilename, operation) {
    const dir = dirname(templateFilename);
    const base = basename(templateFilename, '.template.js');

    for (const ASYNC of [true, false]) {
      const isTest = templateFilename.includes('/__tests__/');
      const destExt = isTest ? 'js' : 'mjs';
      const destFilename = join(dir, ASYNC ? `async-${base}.${destExt}` : `${base}.${destExt}`);

      try {
        if (operation === REMOVE) {
          this.generatedPaths.delete(destFilename);
          if (isGeneratedFromTemplate(destFilename)) {
            fs.unlinkSync(destFilename);
          }
        } else {
          let content
          let pathToTemplate = relative(dirname(destFilename), templateFilename)

          try {
            const impl = babel.transformFileSync(templateFilename, {
              caller: { name: 'generate', ASYNC },
              configFile: join(__dirname, 'babel-generate.config.js'),
            }).code;

            const template = isTest ? generatedTestFile : generatedFunctionFile;
            const templateOutput = template(pathToTemplate, impl);

            content = this.linter.executeOnText(templateOutput).results[0].output;
          } catch(e) {
            content = generationErrorFile(pathToTemplate, e);
          }

          fs.writeFileSync(destFilename, content, 'utf8');
          this.generatedPaths.add(destFilename);
        }
      } catch (e) {
        handleError(e)
      }
    }
  }

  updateMonolithicFiles() {
    const writeTemplate = (path, content) => {
      fs.writeFileSync(join(rootDir, path), content);
      this.generatedPaths.cache(path, { monolithic: true });
    }

    writeTemplate('src/__tests__/fns.js', test$File(this.paths, false));
    writeTemplate('src/__tests__/async-fns.js', test$File(this.paths, true));
    writeTemplate('.gitattributes', gitattributesFile(this.generatedPaths));
  }

  addPath(path) {
    if (isTemplate(path)) {
      this.paths.add(path);
      this.processPath(path, ADD);
      this.updateMonolithicFiles();
      log.info(`Picked up new method template: ${path}`);
    }
  }

  removePath(path) {
    if (isTemplate(path)) {
      this.paths.delete(path);
      this.processPath(path, REMOVE);
      this.updateMonolithicFiles();
      log.info(`Removed files generated by deleted template: ${path}`);
    }
  }

  updatePath(path) {
    if (isTemplate(path)) {
      this.processPath(path);
    } else if (
      this.generatedPaths.getAttribute(path, 'monolithic') &&
      this.generatedPaths.isStale(path)
    ) {
      this.updateMonolithicFiles();
    }
  }

  /**
   * Use a file watcher to incrementally rebuild when files change
   */
  watch() {
    const watcher = sane(rootDir, { glob: ['.gitattributes', 'src/**/*.?(m)js'], ignored });

    watcher.on('add', path => this.addPath(path));
    watcher.on('delete', path => this.removePath(path));
    watcher.on('change', path => this.updatePath(path));
  }

  /**
   * Do an initial tree traversal, then watch for changes
   */
  generate() {
    traverse(rootDir, { glob: 'src/**/*.template.js', ignored }).then(initialPaths => {
      this.generatedPaths.cache('.gitattributes', { monolithic: true });

      for (const path of initialPaths) {
        this.paths.add(path);
        this.processPath(path, ADD);
      }

      this.updateMonolithicFiles();

      if (argv.watch) {
        log.info('Initial generation completed; watching for changes...');
        this.watch()
      };
    }).catch(handleError);
  }
}

module.exports = Generator;
